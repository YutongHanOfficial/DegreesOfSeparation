<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Small-World Degrees of Separation</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0f1117;
      color: white;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin: 20px 0;
      font-size: 24px;
    }
    .controls {
      margin: 10px auto;
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
    }
    .controls label {
      display: flex;
      flex-direction: column;
      font-size: 14px;
      color: #ddd;
    }
    .chart {
      margin-top: 30px;
    }
    svg {
      background: #181b25;
      margin: 20px auto;
      display: block;
      border-radius: 12px;
    }
    .bar {
      fill: #4cc9f0;
    }
    .bar:hover {
      fill: #ffcc00;
    }
    .axis text {
      fill: white;
    }
    .axis path, .axis line {
      stroke: white;
    }
    #results {
      margin-top: 20px;
      font-size: 16px;
      color: #ddd;
    }
    #results ul {
      list-style: none;
      padding: 0;
    }
  </style>
</head>
<body>
  <h1>Small-World Simulation: Degrees of Separation</h1>
  <div class="controls">
    <label>
      People
      <input type="number" id="nodesInput" min="100" max="2000" value="1000">
    </label>
    <label>
      Cluster size
      <input type="number" id="clusterInput" min="5" max="200" value="100">
    </label>
    <label>
      Random % (shortcuts)
      <input type="range" id="rewireRange" min="0" max="100" value="5">
      <span id="rewireValue">5%</span>
    </label>
    <button id="runBtn">Run Simulation</button>
  </div>

  <svg id="chart" width="800" height="400"></svg>
  <h2 id="avgLabel"></h2>
  <div id="results"></div>

  <script>
    // Generate clustered + random graph
    function generateGraph(N, K, beta) {
      let edges = [];
      for (let i = 0; i < N; i++) {
        for (let j = 1; j <= K; j++) {
          let target = (i + j) % N;
          if (Math.random() < beta) {
            target = Math.floor(Math.random() * N);
            if (target === i) continue;
          }
          edges.push([i, target]);
          edges.push([target, i]); // undirected
        }
      }
      return edges;
    }

    // Compute all pairs shortest paths distribution
    function computeShortestPaths(N, edges) {
      let adj = Array.from({ length: N }, () => []);
      edges.forEach(([u, v]) => adj[u].push(v));

      let distCounts = {};
      let totalDist = 0, totalPairs = 0;

      for (let start = 0; start < N; start++) {
        let dist = Array(N).fill(-1);
        dist[start] = 0;
        let queue = [start];

        while (queue.length) {
          let u = queue.shift();
          for (let v of adj[u]) {
            if (dist[v] === -1) {
              dist[v] = dist[u] + 1;
              queue.push(v);
            }
          }
        }

        for (let end = 0; end < N; end++) {
          if (end !== start && dist[end] > 0) {
            distCounts[dist[end]] = (distCounts[dist[end]] || 0) + 1;
            totalDist += dist[end];
            totalPairs++;
          }
        }
      }
      let avg = totalDist / totalPairs;
      return { distCounts, avg };
    }

    // Draw histogram chart
    function drawChart(distCounts, avg) {
      const svg = d3.select("#chart");
      svg.selectAll("*").remove();

      const data = Object.entries(distCounts).map(([d, c]) => ({ degree: +d, count: c }));

      const width = +svg.attr("width");
      const height = +svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 40, left: 60 };

      const x = d3.scaleBand()
        .domain(data.map(d => d.degree))
        .range([margin.left, width - margin.right])
        .padding(0.1);

      const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.count)]).nice()
        .range([height - margin.bottom, margin.top]);

      svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .attr("class", "axis")
        .call(d3.axisBottom(x));

      svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .attr("class", "axis")
        .call(d3.axisLeft(y));

      svg.append("g")
        .selectAll("rect")
        .data(data)
        .join("rect")
        .attr("class", "bar")
        .attr("x", d => x(d.degree))
        .attr("y", d => y(d.count))
        .attr("height", d => y(0) - y(d.count))
        .attr("width", x.bandwidth());

      d3.select("#avgLabel").text(`Average Degrees of Separation: ${avg.toFixed(2)}`);

      // Show exact counts
      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = "<h3>People per Degree of Separation</h3>";
      const ul = document.createElement("ul");
      data.forEach(d => {
        const li = document.createElement("li");
        li.textContent = `Degree ${d.degree}: ${d.count} people`;
        ul.appendChild(li);
      });
      resultsDiv.appendChild(ul);
    }

    // Controls
    const rewireRange = document.getElementById("rewireRange");
    const rewireValue = document.getElementById("rewireValue");
    rewireRange.oninput = () => {
      rewireValue.textContent = rewireRange.value + "%";
    };

    document.getElementById("runBtn").onclick = () => {
      const N = +document.getElementById("nodesInput").value;
      const K = +document.getElementById("clusterInput").value;
      const beta = +rewireRange.value / 100;

      const edges = generateGraph(N, K, beta);
      const { distCounts, avg } = computeShortestPaths(N, edges);
      drawChart(distCounts, avg);
    };

    // Run once on load
    document.getElementById("runBtn").click();
  </script>
</body>
</html>
